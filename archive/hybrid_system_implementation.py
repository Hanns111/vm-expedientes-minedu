#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SISTEMA H√çBRIDO - Combinaci√≥n Inteligente de TF-IDF, BM25 y Transformers
========================================================================

Objetivo: Crear un sistema que combine las fortalezas de los 3 m√©todos:
- TF-IDF: B√∫squeda l√©xica tradicional
- BM25: Ranking mejorado y velocidad
- Transformers: Comprensi√≥n sem√°ntica

Estrategia: Ponderaci√≥n inteligente + Re-ranking + Fusi√≥n de resultados
"""

import sys
import os
import json
import time
import numpy as np
from datetime import datetime
from collections import defaultdict, Counter

# A√±adir ruta del proyecto
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)

class HybridSearchSystem:
    """Sistema de b√∫squeda h√≠brido que combina TF-IDF, BM25 y Transformers"""
    
    def __init__(self):
        self.systems = {}
        self.weights = {
            'tfidf': 0.3,      # 30% - B√∫squeda l√©xica b√°sica
            'bm25': 0.4,       # 40% - Ranking mejorado
            'transformers': 0.3 # 30% - Comprensi√≥n sem√°ntica
        }
        self.performance_cache = {}
        self._initialize_systems()
    
    def _initialize_systems(self):
        """Inicializar los 3 sistemas de b√∫squeda"""
        print("üîß Inicializando Sistema H√≠brido...")
        
        # 1. TF-IDF System
        try:
            from src.ai.search_vectorstore_hybrid import SearchVectorstore
            tfidf_search = SearchVectorstore('data/processed/vectorstore_semantic_full_v2.pkl')
            self.systems['tfidf'] = {
                'instance': tfidf_search,
                'status': 'ready',
                'description': 'TF-IDF + Cosine Similarity'
            }
            print("‚úÖ TF-IDF System: Listo")
        except Exception as e:
            print(f"‚ö†Ô∏è TF-IDF System: Error - {e}")
            self.systems['tfidf'] = {'status': 'error', 'error': str(e)}
        
        # 2. BM25 System (Versi√≥n corregida)
        try:
            from src.ai.search_vectorstore_bm25_fixed import BM25SearchFixed
            bm25_search = BM25SearchFixed('data/processed/vectorstore_bm25_test.pkl')
            self.systems['bm25'] = {
                'instance': bm25_search,
                'status': 'ready',
                'description': 'BM25 Okapi + Boosting'
            }
            print("‚úÖ BM25 System: Listo")
        except Exception as e:
            print(f"‚ö†Ô∏è BM25 System: Error - {e}")
            self.systems['bm25'] = {'status': 'error', 'error': str(e)}
        
        # 3. Transformers System
        try:
            from src.ai.search_vectorstore_transformers import TransformersSearch
            transformers_search = TransformersSearch('data/processed/vectorstore_transformers_test.pkl')
            self.systems['transformers'] = {
                'instance': transformers_search,
                'status': 'ready',
                'description': 'Sentence Transformers + Embeddings'
            }
            print("‚úÖ Transformers System: Listo")
        except Exception as e:
            print(f"‚ö†Ô∏è Transformers System: Error - {e}")
            self.systems['transformers'] = {'status': 'error', 'error': str(e)}
        
        # Resumen de inicializaci√≥n
        ready_systems = sum(1 for s in self.systems.values() if s.get('status') == 'ready')
        print(f"üéØ Sistemas listos: {ready_systems}/3")
    
    def search_individual_system(self, query, system_name, top_k=5):
        """Buscar en un sistema individual"""
        system = self.systems.get(system_name)
        if not system or system.get('status') != 'ready':
            return []
        
        try:
            start_time = time.time()
            
            if system_name == 'tfidf':
                results = system['instance'].search(query, top_k=top_k)
                # Normalizar formato TF-IDF
                normalized_results = []
                for i, result in enumerate(results.get('results', [])[:top_k]):
                    normalized_results.append({
                        'score': float(result.get('score', 0.5)),
                        'texto': str(result.get('texto', result.get('text', ''))),
                        'titulo': f"TF-IDF Result {i+1}",
                        'source': 'tfidf',
                        'index': i
                    })
                results = normalized_results
                
            elif system_name == 'bm25':
                results = system['instance'].search(query, top_k=top_k)
                # BM25 ya devuelve formato normalizado
                
            elif system_name == 'transformers':
                results = system['instance'].search(query, top_k=top_k)
                # Normalizar formato Transformers
                normalized_results = []
                for i, result in enumerate(results.get('results', [])[:top_k]):
                    normalized_results.append({
                        'score': float(result.get('score', result.get('similarity', 0.5))),
                        'texto': str(result.get('texto', result.get('text', result.get('content', '')))),
                        'titulo': f"Semantic Result {i+1}",
                        'source': 'transformers',
                        'index': i
                    })
                results = normalized_results
            
            elapsed_time = time.time() - start_time
            
            # Cache performance
            self.performance_cache[system_name] = {
                'last_query_time': elapsed_time,
                'last_result_count': len(results),
                'timestamp': datetime.now().isoformat()
            }
            
            return results
            
        except Exception as e:
            print(f"‚ùå Error en {system_name}: {e}")
            return []
    
    def hybrid_search(self, query, top_k=10):
        """B√∫squeda h√≠brida que combina los 3 sistemas"""
        print(f"üîç B√∫squeda H√≠brida: '{query}'")
        print("=" * 50)
        
        # Paso 1: Obtener resultados de cada sistema
        all_results = {}
        individual_times = {}
        
        for system_name in ['tfidf', 'bm25', 'transformers']:
            print(f"üìä Consultando {system_name.upper()}...")
            start = time.time()
            results = self.search_individual_system(query, system_name, top_k=top_k)
            individual_times[system_name] = time.time() - start
            all_results[system_name] = results
            print(f"   ‚è±Ô∏è {individual_times[system_name]:.4f}s - {len(results)} resultados")
        
        # Paso 2: Fusi√≥n inteligente de resultados
        print("\nüîÑ Fusionando resultados...")
        fused_results = self._fuse_results(all_results, query)
        
        # Paso 3: Re-ranking final
        print("üéØ Re-ranking final...")
        final_results = self._rerank_results(fused_results, query)[:top_k]
        
        # Estad√≠sticas finales
        total_time = sum(individual_times.values())
        print(f"\nüìä ESTAD√çSTICAS H√çBRIDAS:")
        print(f"   ‚è±Ô∏è Tiempo total: {total_time:.4f}s")
        print(f"   üéØ Resultados finales: {len(final_results)}")
        print(f"   üìà Sistemas contribuyendo: {len([s for s in all_results if all_results[s]])}/3")
        
        return {
            'results': final_results,
            'metadata': {
                'individual_times': individual_times,
                'total_time': total_time,
                'systems_used': list(all_results.keys()),
                'fusion_method': 'weighted_combination',
                'query': query,
                'timestamp': datetime.now().isoformat()
            }
        }
    
    def _fuse_results(self, all_results, query):
        """Fusionar resultados de m√∫ltiples sistemas con ponderaci√≥n inteligente"""
        fused = []
        seen_texts = set()
        
        # Crear √≠ndice de todos los resultados √∫nicos
        unique_results = {}
        
        for system_name, results in all_results.items():
            weight = self.weights.get(system_name, 0.33)
            
            for result in results:
                text_key = result.get('texto', '')[:100]  # Usar primeros 100 chars como clave
                
                if text_key not in unique_results:
                    unique_results[text_key] = {
                        'texto': result.get('texto', ''),
                        'titulo': result.get('titulo', f'Resultado fusionado'),
                        'combined_score': 0.0,
                        'contributing_systems': [],
                        'individual_scores': {},
                        'fusion_details': {}
                    }
                
                # Acumular scores ponderados
                weighted_score = result.get('score', 0) * weight
                unique_results[text_key]['combined_score'] += weighted_score
                unique_results[text_key]['contributing_systems'].append(system_name)
                unique_results[text_key]['individual_scores'][system_name] = result.get('score', 0)
                unique_results[text_key]['fusion_details'][system_name] = {
                    'original_score': result.get('score', 0),
                    'weight_applied': weight,
                    'weighted_contribution': weighted_score
                }
        
        # Convertir a lista y ordenar por score combinado
        fused = list(unique_results.values())
        fused.sort(key=lambda x: x['combined_score'], reverse=True)
        
        return fused
    
    def _rerank_results(self, fused_results, query):
        """Re-ranking final basado en m√∫ltiples factores"""
        for result in fused_results:
            # Factor de diversidad (bonus por m√∫ltiples sistemas)
            diversity_bonus = len(result['contributing_systems']) * 0.1
            
            # Factor de consenso (bonus si m√∫ltiples sistemas est√°n de acuerdo)
            consensus_bonus = 0
            if len(result['contributing_systems']) >= 2:
                scores = list(result['individual_scores'].values())
                if len(scores) >= 2:
                    score_std = np.std(scores)
                    consensus_bonus = max(0, (1.0 - score_std) * 0.2)  # Bonus si scores son similares
            
            # Factor de relevancia de texto (simplificado)
            query_words = query.lower().split()
            text_lower = result['texto'].lower()
            word_matches = sum(1 for word in query_words if word in text_lower)
            relevance_bonus = (word_matches / len(query_words)) * 0.1 if query_words else 0
            
            # Score final
            result['final_score'] = (
                result['combined_score'] + 
                diversity_bonus + 
                consensus_bonus + 
                relevance_bonus
            )
            
            # Metadata del re-ranking
            result['rerank_factors'] = {
                'original_combined': result['combined_score'],
                'diversity_bonus': diversity_bonus,
                'consensus_bonus': consensus_bonus,
                'relevance_bonus': relevance_bonus,
                'final_score': result['final_score']
            }
        
        # Ordenar por score final
        fused_results.sort(key=lambda x: x['final_score'], reverse=True)
        return fused_results
    
    def evaluate_hybrid_performance(self, test_queries):
        """Evaluar rendimiento del sistema h√≠brido vs sistemas individuales"""
        print("üìä EVALUACI√ìN DE RENDIMIENTO H√çBRIDO")
        print("=" * 45)
        
        results = {
            'hybrid': {'times': [], 'result_counts': []},
            'individual': {system: {'times': [], 'result_counts': []} for system in self.systems.keys()}
        }
        
        for i, query in enumerate(test_queries, 1):
            print(f"\nüîç Query {i}/{len(test_queries)}: {query[:50]}...")
            
            # Probar sistema h√≠brido
            start = time.time()
            hybrid_result = self.hybrid_search(query, top_k=5)
            hybrid_time = time.time() - start
            
            results['hybrid']['times'].append(hybrid_time)
            results['hybrid']['result_counts'].append(len(hybrid_result.get('results', [])))
            
            # Probar sistemas individuales
            for system_name in self.systems.keys():
                if self.systems[system_name].get('status') == 'ready':
                    start = time.time()
                    individual_results = self.search_individual_system(query, system_name, top_k=5)
                    individual_time = time.time() - start
                    
                    results['individual'][system_name]['times'].append(individual_time)
                    results['individual'][system_name]['result_counts'].append(len(individual_results))
        
        # Calcular estad√≠sticas
        print("\nüìä ESTAD√çSTICAS COMPARATIVAS:")
        
        # Sistema h√≠brido
        hybrid_avg_time = np.mean(results['hybrid']['times'])
        hybrid_avg_results = np.mean(results['hybrid']['result_counts'])
        print(f"\nüîÑ SISTEMA H√çBRIDO:")
        print(f"   ‚è±Ô∏è Tiempo promedio: {hybrid_avg_time:.4f}s")
        print(f"   üìä Resultados promedio: {hybrid_avg_results:.1f}")
        
        # Sistemas individuales
        print(f"\nüìã SISTEMAS INDIVIDUALES:")
        for system_name, data in results['individual'].items():
            if data['times']:  # Solo si tiene datos
                avg_time = np.mean(data['times'])
                avg_results = np.mean(data['result_counts'])
                print(f"   {system_name.upper()}: {avg_time:.4f}s, {avg_results:.1f} resultados")
        
        return results

def test_hybrid_system():
    """Funci√≥n de prueba completa del sistema h√≠brido"""
    print("üöÄ PRUEBA COMPLETA DEL SISTEMA H√çBRIDO")
    print("üéØ Objetivo: Validar funcionamiento y rendimiento")
    print("=" * 55)
    
    # Inicializar sistema h√≠brido
    hybrid = HybridSearchSystem()
    
    # Queries de prueba
    test_queries = [
        "¬øCu√°l es el monto m√°ximo para vi√°ticos?",
        "¬øQu√© documentos se requieren para vi√°ticos?",
        "¬øCu√°l es el procedimiento para solicitar vi√°ticos?",
        "¬øQui√©n autoriza los vi√°ticos en el MINEDU?",
        "¬øCu√°les son las responsabilidades del comisionado?"
    ]
    
    # Prueba individual de una query
    print("\nüß™ PRUEBA INDIVIDUAL:")
    query = test_queries[0]
    hybrid_result = hybrid.hybrid_search(query, top_k=5)
    
    print(f"\nüìã RESULTADOS PARA: '{query}'")
    for i, result in enumerate(hybrid_result['results'][:3], 1):
        print(f"\nüìÑ Resultado {i}:")
        print(f"   üéØ Score: {result['final_score']:.4f}")
        print(f"   üè∑Ô∏è T√≠tulo: {result['titulo']}")
        print(f"   üìù Texto: {result['texto'][:100]}...")
        print(f"   üîó Sistemas: {', '.join(result['contributing_systems'])}")
    
    # Evaluaci√≥n completa
    print(f"\nüî¨ EVALUACI√ìN COMPLETA ({len(test_queries)} queries):")
    performance_results = hybrid.evaluate_hybrid_performance(test_queries)
    
    # Guardar resultados
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    results_file = f"data/evaluation/hybrid_system_evaluation_{timestamp}.json"
    
    os.makedirs("data/evaluation", exist_ok=True)
    
    evaluation_data = {
        'timestamp': timestamp,
        'test_queries': test_queries,
        'sample_result': hybrid_result,
        'performance_comparison': performance_results,
        'system_config': {
            'weights': hybrid.weights,
            'systems_available': [name for name, system in hybrid.systems.items() if system.get('status') == 'ready']
        }
    }
    
    with open(results_file, 'w', encoding='utf-8') as f:
        json.dump(evaluation_data, f, indent=2, ensure_ascii=False)
    
    print(f"\nüíæ Resultados guardados: {results_file}")
    
    return hybrid, evaluation_data

def main():
    """Funci√≥n principal"""
    print("üîÑ IMPLEMENTACI√ìN DEL SISTEMA H√çBRIDO")
    print("üéØ Combinando TF-IDF + BM25 + Transformers")
    print("=" * 50)
    
    try:
        # Ejecutar prueba completa
        hybrid_system, results = test_hybrid_system()
        
        print("\n" + "=" * 55)
        print("üéâ SISTEMA H√çBRIDO IMPLEMENTADO EXITOSAMENTE")
        print("=" * 55)
        
        # Mostrar resumen final
        systems_working = len([s for s in hybrid_system.systems.values() if s.get('status') == 'ready'])
        print(f"‚úÖ Sistemas integrados: {systems_working}/3")
        print(f"‚úÖ Fusi√≥n de resultados: Funcional")
        print(f"‚úÖ Re-ranking inteligente: Funcional")
        print(f"‚úÖ Evaluaci√≥n de rendimiento: Completada")
        
        print(f"\nüöÄ LISTO PARA:")
        print(f"   üìù Paper Cient√≠fico (30 min)")
        print(f"   üî¨ Evaluaciones avanzadas")
        print(f"   üéØ Optimizaci√≥n de par√°metros")
        
        return True
        
    except Exception as e:
        print(f"\n‚ùå Error en implementaci√≥n: {e}")
        import traceback
        print(traceback.format_exc())
        return False

if __name__ == "__main__":
    success = main()
    if success:
        print("\n‚úÖ ¬°SISTEMA H√çBRIDO COMPLETADO!")
        print("üéØ Siguiente: Paper Cient√≠fico")
    else:
        print("\n‚ùå Revisar errores y reintentar") 